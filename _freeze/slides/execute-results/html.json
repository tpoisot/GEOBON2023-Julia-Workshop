{
  "hash": "332f941bfc24760cdf7c0eb9992c3e73",
  "result": {
    "markdown": "---\ntitle: \"Building an interpretable SDM from scratch\"\nsubtitle: \"using Julia 1.9\"\nauthor:\n    name: \"Timothée Poisot\"\n    email: timothee.poisot@umontreal.ca\ninstitute: \"Université de Montréal\"\ntitle-slide-attributes: \n  data-background-image: https://cdn.pixabay.com/photo/2017/03/29/11/29/nepal-2184940_960_720.jpg\n  data-background-opacity: \"0.15\"\nbibliography: references.bib\ncsl: https://www.zotero.org/styles/ecology-letters\n---\n\n## Overview\n\n-   Build a *simple* classifier to predict the distribution of a species\n\n-   No, I will not tell you which species, it's a large North American mammal\n\n-   Use this as an opportunity to talk about interpretable ML\n\n-   Discuss which biases are appropriate in a predictive model\n\n::: footer\nCC BY 4.0 - Timothée Poisot\n:::\n\n------------------------------------------------------------------------\n\n::: r-fit-text\nWe care a lot about the\n\n**process**\n\nand only a little about the\n\n**product**\n:::\n\n------------------------------------------------------------------------\n\n## Why...\n\n... think of SDMs as a ML problem?\n\n:   They are (they really, really are, see @beery2021)\n\n... think of explainable ML for SDM?\n\n:   Uptake of models *requires* transparent predictions\n\n... not tell us which species this is about?\n\n:   Because this is the point (you'll see)\n\n## Do try this at home!\n\n💻 + 📔 + 🗺️ at `https://github.com/tpoisot/InterpretableSDMWithJulia/`\n\n::: {#include-the-packages-we-need .cell execution_count=1}\n``` {.julia .cell-code}\ninclude(joinpath(\"code\", \"pkg.jl\")); # Dependencies\ninclude(joinpath(\"code\", \"nbc.jl\")); # Naive Bayes Classifier\ninclude(joinpath(\"code\", \"bioclim.jl\")); # BioClim model\ninclude(joinpath(\"code\", \"confusion.jl\")); # Confusion matrix utilities\ninclude(joinpath(\"code\", \"splitters.jl\")); # Cross-validation (part one)\ninclude(joinpath(\"code\", \"crossvalidate.jl\")); # Cross-validation (part deux)\ninclude(joinpath(\"code\", \"variableselection.jl\")); # Variable selection\ninclude(joinpath(\"code\", \"shapley.jl\")); # Shapley values\ninclude(joinpath(\"code\", \"palettes.jl\")); # Accessible color palettes\n```\n:::\n\n\n## Species occurrences\n\n::: {#get-the-species-data .cell execution_count=2}\n``` {.julia .cell-code}\nsightings = CSV.File(\"occurrences.csv\")\nocc = [\n    (record.longitude, record.latitude)\n    for record in sightings\n    if record.classification == \"Class A\"\n]\nfilter!(r -> -90 <= r[2] <= 90, occ)\nfilter!(r -> -180 <= r[1] <= 180, occ)\nboundingbox = (\n    left = minimum(first.(occ)),\n    right = maximum(first.(occ)),\n    bottom = minimum(last.(occ)),\n    top = maximum(last.(occ)),\n)\n```\n:::\n\n\n## Bioclimatic data\n\nWe collect BioClim data from CHELSA v1, using `SpeciesDistributionToolkit`\n\n::: {#download-the-bioclim-data-from-worldclim2 .cell execution_count=3}\n``` {.julia .cell-code}\nprovider = RasterData(WorldClim2, BioClim)\nopts = (; resolution=5.0)\ntemperature = SimpleSDMPredictor(provider, layer=1; opts..., boundingbox...)\n```\n:::\n\n\n::: footer\nBioClim data from @karger2020; see @dansereau2021 for more about the packages\n:::\n\n## Bioclimatic data\n\nWe set the pixels with only open water to `nothing`\n\n::: {#get-the-open-water-pixels .cell execution_count=4}\n``` {.julia .cell-code}\nwater = \n    SimpleSDMPredictor(RasterData(EarthEnv, LandCover), layer=12; boundingbox...)\nland = similar(temperature, Bool)\nreplace!(land, false => true)\nfor k in keys(land)\n    if !isnothing(water[k])\n        if water[k] == 100\n            land[k] = false\n        end\n    end\nend\ntemperature = mask(land, temperature)\n```\n:::\n\n\n::: footer\nLand-cover data from @tuanmu2014\n:::\n\n## Where are we so far?\n\n::: {#531a2192 .cell execution_count=5}\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](slides_files/figure-revealjs/cell-6-output-1.png){}\n:::\n:::\n\n\n## Spatial thinning\n\nWe limit the occurrences to one per grid cell, assigned to the center of the grid cell\n\n::: {#make-the-layer-for-presences .cell execution_count=6}\n``` {.julia .cell-code}\npresence_layer = similar(temperature, Bool)\nfor i in axes(occ, 1)\n    if ~isnothing(presence_layer[occ[i]...])\n        presence_layer[occ[i]...] = true\n    end\nend\n```\n:::\n\n\n## Background points generation\n\nWe generate background points proportionally to the distance away from observations, with a 10km buffer around each point with no background point allowed:\n\n::: {#make-the-pseudo-absence-buffer .cell execution_count=7}\n``` {.julia .cell-code}\npossible_background = pseudoabsencemask(DistanceToEvent, presence_layer)\n```\n:::\n\n\nAnd then we sample three pseudo-absence for each occurrence:\n\n::: {#make-the-absence-layer .cell execution_count=8}\n``` {.julia .cell-code}\nabsence_layer = backgroundpoints(\n    (x -> x^1.01).(possible_background), \n    3sum(presence_layer);\n    replace=false\n)\n```\n:::\n\n\n::: footer\nSee @barbet-massin2012 for more on background points\n:::\n\n## Background points cleaning\n\nWe can remove all of the information that is neither a presence nor a pseudo-absence\n\n::: {#pseudo-absencepresence-remove .cell execution_count=9}\n``` {.julia .cell-code}\nreplace!(absence_layer, false => nothing)\nreplace!(presence_layer, false => nothing)\n```\n:::\n\n\n## Data overview\n\n::: {#dc996091 .cell execution_count=10}\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](slides_files/figure-revealjs/cell-11-output-1.png){}\n:::\n:::\n\n\n\n\n## Preparing the responses and variables\n\n::: {#assemble-y-and-x .cell execution_count=12}\n``` {.julia .cell-code}\nXpresence = hcat([bioclim_var[keys(presence_layer)] for bioclim_var in predictors]...)\nypresence = fill(true, length(presence_layer))\nXabsence = hcat([bioclim_var[keys(absence_layer)] for bioclim_var in predictors]...)\nyabsence = fill(false, length(absence_layer))\nX = vcat(Xpresence, Xabsence)\ny = vcat(ypresence, yabsence)\n```\n:::\n\n\n\n\n## The model -- Naive Bayes Classifier\n\nPrediction:\n\n$$\nP(+|x) = \\frac{P(+)}{P(x)}P(x|+)\n$$\n\nDecision rule:\n\n$$\n\\hat y = \\text{argmax}_j \\, P(\\mathbf{c}_j)\\prod_i P(\\mathbf{x}_i|\\mathbf{c}_j)\n$$\n\n::: footer\nWith $n$ instances and $f$ features, NBC trains *and* predicts in $\\mathcal{O}(n\\times f)$\n:::\n\n## The model -- Naive Bayes Classifier\n\nAssumption of Gaussian distributions:\n\n$$\nP(x|+) = \\text{pdf}(x, \\mathcal{N}(\\mu_+, \\sigma_+))\n$$\n\n## Cross-validation\n\nWe keep an **unseen** *testing* set -- this will be used at the very end to report expected model performance\n\n::: {#testing-set .cell execution_count=14}\n``` {.julia .cell-code}\nidx, tidx = holdout(y, X; permute=true)\n```\n:::\n\n\nFor *validation*, we will run k-folds\n\n::: {#k-folds .cell execution_count=15}\n``` {.julia .cell-code}\nty, tX = y[idx], X[idx,:]\nfolds = kfold(ty, tX; k=15, permute=true)\nk = length(folds)\n```\n:::\n\n\n::: footer\nSee @valavi2018 for more on cross-validation\n:::\n\n## A note on cross-validation\n\nAll models share the same folds\n\n:   we can compare the validation performance across experiments to select the best model\n\nModel performance can be compared\n\n:   we average the relevant summary statistics over each validation set\n\nTesting set is *only* for future evaluation\n\n:   we can only use it once and report the expected performance *of the best model*\n\n## Baseline performance\n\nWe need to get a sense of how difficult the classification problem is:\n\n::: {#0547833b .cell execution_count=16}\n``` {.julia .cell-code}\nN_v0 = crossvalidate(naivebayes, ty, tX, folds)\nB_v0 = crossvalidate(bioclim, ty, tX, folds, eps())\n```\n:::\n\n\nThis uses an un-tuned model with all variables and reports the average over all validation sets. In addition, we will always use the BioClim model as a comparison.\n\n## Measures on the confusion matrix {.smaller}\n\n|     | BioClim                       | NBC                           |\n|-----|-------------------------------|-------------------------------|\n| FPR | 0\\.26±0\\.0       | 0\\.11±0\\.0       |\n| FNR | 0\\.02±0\\.0       | 0\\.15±0\\.0       |\n| TPR | 0\\.98±0\\.0       | 0\\.85±0\\.0       |\n| TNR | 0\\.74±0\\.0       | 0\\.89±0\\.0       |\n| TSS | 0\\.72±0\\.0 | 0\\.74±0\\.0 |\n| MCC | 0\\.63±0\\.0       | 0\\.7±0\\.0       |\n\n::: footer\nIt's a good idea to check the values for the training sets too...\n:::\n\n## Variable selection\n\nWe add variables one at a time, until the Matthew's Correlation Coefficient stops increasing -- we keep annual temperature, isothermality, mean diurnal range, and annual precipitation\n\n::: {#0ca04b73 .cell execution_count=17}\n``` {.julia .cell-code}\navailable_variables = forwardselection(ty, tX, folds, naivebayes, mcc)\n```\n:::\n\n\nThis method identifies 7 variables, some of which are:\n\n1.  Mean Temp\\. of Coldest Quarter\n\n2.  Mean Diurnal Range \n\n3.  Annual Precip\\.\n\n## Variable selection?\n\n-   Constrained variable selection\n\n-   VIF threshold (over the extent or over document occurrences?)\n\n-   PCA for dimensionality reduction *v.* Whitening for colinearity removal\n\n-   Potential for data leakage: data transformations don't exist, they are just models we can train\n\n## Model with variable selection\n\n::: {#b075c902 .cell execution_count=18}\n``` {.julia .cell-code}\nN_v1 = crossvalidate(naivebayes, ty, tX[:,available_variables], folds)\nB_v1 = crossvalidate(bioclim, ty, tX[:,available_variables], folds, eps())\n```\n:::\n\n\n## Measures on the confusion matrix {.smaller}\n\n|     | BioClim                       | NBC                           | BioClim (v.s.)                | NBC (v.s.)                    |\n|---------------|---------------|---------------|---------------|---------------|\n| FPR | 0\\.26±0\\.0       | 0\\.11±0\\.0       | 0\\.32±0\\.0       | 0\\.08±0\\.0       |\n| FNR | 0\\.02±0\\.0       | 0\\.15±0\\.0       | 0\\.01±0\\.0       | 0\\.14±0\\.0       |\n| TPR | 0\\.98±0\\.0       | 0\\.85±0\\.0       | 0\\.99±0\\.0       | 0\\.86±0\\.0       |\n| TNR | 0\\.74±0\\.0       | 0\\.89±0\\.0       | 0\\.68±0\\.0       | 0\\.92±0\\.0       |\n| TSS | 0\\.72±0\\.0 | 0\\.74±0\\.0 | 0\\.67±0\\.0 | 0\\.77±0\\.0 |\n| MCC | 0\\.63±0\\.0       | 0\\.7±0\\.0       | 0\\.58±0\\.0       | 0\\.75±0\\.0       |\n\n## How do we make the model better?\n\nThe NBC is a *probabilistic classifier* returning $P(+|\\mathbf{x})$\n\nThe *decision rule* is to assign a presence when $P(\\cdot) > 0.5$\n\nBut $P(\\cdot) > \\tau$ is a far more general approach, and we can use learning curves to identify $\\tau$\n\n## Thresholding the model\n\n::: {#fae762cd .cell execution_count=19}\n``` {.julia .cell-code}\nthr = LinRange(0.0, 1.0, 500)\nT = hcat([crossvalidate(naivebayes, ty, tX[:,available_variables], folds, t) for t in thr]...)\n```\n:::\n\n\n## But how do we pick the threshold?\n\n::: {#1617d485 .cell execution_count=20}\n\n::: {.cell-output .cell-output-display execution_count=24}\n![](slides_files/figure-revealjs/cell-21-output-1.svg){}\n:::\n:::\n\n\n## Tuned model with selected variables\n\n::: {#354ac9eb .cell execution_count=21}\n``` {.julia .cell-code}\nN_v2 = crossvalidate(naivebayes, ty, tX[:,available_variables], folds, thr[m])\n```\n:::\n\n\n## Measures on the confusion matrix {.smaller}\n\n|     | BioClim                       | NBC                           | BioClim (v.s.)                | NBC (v.s.)                    | NBC (v.s. + tuning)           |\n|------------|------------|------------|------------|------------|------------|\n| FPR | 0\\.26±0\\.0       | 0\\.11±0\\.0       | 0\\.32±0\\.0       | 0\\.08±0\\.0       | 0\\.08±0\\.0       |\n| FNR | 0\\.02±0\\.0       | 0\\.15±0\\.0       | 0\\.01±0\\.0       | 0\\.14±0\\.0       | 0\\.15±0\\.0       |\n| TPR | 0\\.98±0\\.0       | 0\\.85±0\\.0       | 0\\.99±0\\.0       | 0\\.86±0\\.0       | 0\\.85±0\\.0       |\n| TNR | 0\\.74±0\\.0       | 0\\.89±0\\.0       | 0\\.68±0\\.0       | 0\\.92±0\\.0       | 0\\.92±0\\.0       |\n| TSS | 0\\.72±0\\.0 | 0\\.74±0\\.0 | 0\\.67±0\\.0 | 0\\.77±0\\.0 | 0\\.77±0\\.0 |\n| MCC | 0\\.63±0\\.0       | 0\\.7±0\\.0       | 0\\.58±0\\.0       | 0\\.75±0\\.0       | 0\\.75±0\\.0       |\n\n## How do we make the model better?\n\nThe NBC is a *Bayesian classifier* returning $P(+|\\mathbf{x})$\n\nThe *actual probability* depends on $P(+)$\n\nThere is no reason not to also tune $P(+)$ (jointly with other hyper-parameters)!\n\n## Joint tuning of hyper-parameters\n\n::: {#31feb32d .cell execution_count=22}\n``` {.julia .cell-code}\nthr = LinRange(0.0, 1.0, 55)\npplus = LinRange(0.0, 1.0, 45)\nT = [crossvalidate(naivebayes, ty, tX[:,available_variables], folds, t; presence=prior) for t in thr, prior in pplus]\nbest_mcc, params = findmax(map(v -> mean(mcc.(v)), T))\nτ = thr[params.I[1]]\nppres = pplus[params.I[2]]\n```\n:::\n\n\n## Tuned (again) model with selected variables\n\n::: {#d0fe12b2 .cell execution_count=23}\n``` {.julia .cell-code}\nN_v3 = crossvalidate(naivebayes, ty, tX[:,available_variables], folds, τ; presence=ppres)\n```\n:::\n\n\n## Measures on the confusion matrix {.smaller}\n\n|     | BioClim                       | NBC (v0)                      | NBC (v1)                      | NBC (v2)                      | NBC (v3)                      |\n|------------|------------|-------------|------------|------------|------------|\n| FPR | 0\\.26±0\\.0       | 0\\.11±0\\.0       | 0\\.08±0\\.0       | 0\\.08±0\\.0       | 0\\.07±0\\.0       |\n| FNR | 0\\.02±0\\.0       | 0\\.15±0\\.0       | 0\\.14±0\\.0       | 0\\.15±0\\.0       | 0\\.18±0\\.0       |\n| TPR | 0\\.98±0\\.0       | 0\\.85±0\\.0       | 0\\.86±0\\.0       | 0\\.85±0\\.0       | 0\\.82±0\\.0       |\n| TNR | 0\\.74±0\\.0       | 0\\.89±0\\.0       | 0\\.92±0\\.0       | 0\\.92±0\\.0       | 0\\.93±0\\.0       |\n| TSS | 0\\.72±0\\.0 | 0\\.74±0\\.0 | 0\\.77±0\\.0 | 0\\.77±0\\.0 | 0\\.75±0\\.0 |\n| MCC | 0\\.63±0\\.0       | 0\\.7±0\\.0       | 0\\.75±0\\.0       | 0\\.75±0\\.0       | 0\\.75±0\\.0       |\n\n## Tuned model performance\n\nWe can retrain over *all* the training data\n\n::: {#eacef516 .cell execution_count=24}\n``` {.julia .cell-code}\nfinalmodel = naivebayes(ty, tX[:,available_variables]; presence=ppres)\nprediction = vec(mapslices(finalmodel, X[tidx,available_variables]; dims=2))\nC = ConfusionMatrix(prediction, y[tidx], τ)\n```\n:::\n\n\n## Estimated performance\n\n|     | Final model                |\n|-----|----------------------------|\n| FPR | 0\\.06       |\n| FNR | 0\\.17       |\n| TPR | 0\\.83       |\n| TNR | 0\\.94       |\n| TSS | 0\\.76 |\n| MCC | 0\\.76       |\n\n## Acceptable bias\n\n-   false positives: we expect that our knowledge of the distribution is incomplete, and *this is why we train a model*\n\n-   false negatives: the detection of the species is imperfect (we will reveal the species soon)\n\n## Prediction for each pixel\n\n\n\n::: {#64491477 .cell execution_count=26}\n``` {.julia .cell-code}\nprediction = similar(temperature, Float64)\nvariability = similar(temperature, Float64)\nuncertainty = similar(temperature, Float64)\nThreads.@threads for k in keys(prediction)\n    pred_k = [p[k] for p in predictors[available_variables]]\n    bootstraps = [\n            samplemodel(pred_k)\n            for samplemodel in samplemodels\n        ]\n    prediction[k] = finalmodel(pred_k)\n    variability[k] = iqr(bootstraps)\n    uncertainty[k] = entropy(prediction[k])\nend\n```\n:::\n\n\n## Tuned model - prediction\n\n::: {#9fb032aa .cell execution_count=27}\n\n::: {.cell-output .cell-output-display execution_count=34}\n![](slides_files/figure-revealjs/cell-28-output-1.png){}\n:::\n:::\n\n\n## Tuned model - variability in output\n\n::: {#e59d1688 .cell execution_count=28}\n\n::: {.cell-output .cell-output-display execution_count=35}\n![](slides_files/figure-revealjs/cell-29-output-1.png){}\n:::\n:::\n\n\n::: footer\nIQR for 50 bootstrap replicates\n:::\n\n## Tuned model - entropy in probability\n\n::: {#a7b40ef5 .cell execution_count=29}\n\n::: {.cell-output .cell-output-display execution_count=36}\n![](slides_files/figure-revealjs/cell-30-output-1.png){}\n:::\n:::\n\n\n::: footer\nEntropy (in bits) of the NBC probability\n:::\n\n## Tuned model - range\n\n::: {#6924dc95 .cell execution_count=30}\n\n::: {.cell-output .cell-output-display execution_count=37}\n![](slides_files/figure-revealjs/cell-31-output-1.png){}\n:::\n:::\n\n\n::: footer\nProbability \\> 0.648\n:::\n\n## Predicting the predictions?\n\nShapley values (Monte-Carlo approximation): if we mix the variables across two observations, how important is the $i$-th variable?\n\nExpresses \"importance\" as an additive factor on top of the *average* prediction (here: average prob. of occurrence)\n\n::: {#31741315 .cell execution_count=31}\n``` {.julia .cell-code}\nshapval = [similar(first(predictors), Float64) for i in eachindex(available_variables)]\nThreads.@threads for k in keys(shapval[1])\n    x = [p[k] for p in predictors[available_variables]]\n    for i in axes(shapval, 1)\n        shapval[i][k] = shapleyvalues(finalmodel, tX[:,available_variables], x, i; M=50)\n        if isnan(shapval[i][k])\n            shapval[i][k] = 0.0\n        end\n    end\nend\n```\n:::\n\n\n## Importance of variables\n\n::: {#460ee2bb .cell execution_count=32}\n``` {.julia .cell-code}\nvarimp = sum.(map(abs, shapval))\nvarimp ./= sum(varimp)\nfor v in sortperm(varimp, rev=true)\n    vname = variables[available_variables[v]][2]\n    vctr = round(Int, varimp[v]*100)\n    println(\"$(vname) - $(vctr)%\")\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMean Temp. of Coldest Quarter - 26%\nPrecip. of Driest Quarter - 15%\nIsothermality  - 15%\nPrecip. of Coldest Quarter - 14%\nAnnual Precip. - 14%\nMean Diurnal Range  - 8%\nPrecip. Seasonality  - 7%\n```\n:::\n:::\n\n\nThere is a difference between **contributing to model performance** and **contributing to model explainability**\n\n## Top three variables\n\n::: {#a5d89584 .cell execution_count=33}\n\n::: {.cell-output .cell-output-display execution_count=41}\n![](slides_files/figure-revealjs/cell-34-output-1.png){}\n:::\n:::\n\n\n## Most determinant predictor\n\n::: {#d4aeb06f .cell execution_count=34}\n\n::: {.cell-output .cell-output-display execution_count=42}\n![](slides_files/figure-revealjs/cell-35-output-1.png){}\n:::\n:::\n\n\n## But wait...\n\n> What do you think the species was?\n\n## Take-home\n\n-   building a model is *incremental*\n\n-   each step adds arbitrary decisions we can control for, justify, or live with\n\n-   we can provide explanations for every single prediction\n\n-   free online textbook (in development) at `https://tpoisot.github.io/DataSciForBiodivSci/`\n\n## References\n\n",
    "supporting": [
      "slides_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}