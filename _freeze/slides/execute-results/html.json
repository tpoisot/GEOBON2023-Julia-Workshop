{
  "hash": "79bdd799b23fd4fe81ffdb98cc32dacf",
  "result": {
    "markdown": "---\ntitle: \"Building an interpretable SDM from scratch\"\nsubtitle: \"using Julia 1.9\"\nauthor:\n    name: \"Timothée Poisot\"\n    email: timothee.poisot@umontreal.ca\ninstitute: \"Université de Montréal\"\ntitle-slide-attributes: \n  data-background-image: https://cdn.pixabay.com/photo/2019/08/16/23/02/white-breasted-nuthatch-4411169_960_720.jpg\n  data-background-opacity: \"0.15\"\nbibliography: references.bib\ncsl: https://www.zotero.org/styles/ecology-letters\n---\n\n## Overview\n\n-   Build a *simple* classifier to predict the distribution of a species\n\n-   Use this as an opportunity to talk about interpretable ML\n\n-   Discuss which biases are appropriate in a predictive model\n\n::: footer\nCC BY 4.0 - Timothée Poisot\n:::\n\n------------------------------------------------------------------------\n\n::: r-fit-text\nWe care a lot about the\n\n**process**\n\nand only a little about the\n\n**product**\n:::\n\n------------------------------------------------------------------------\n\n## Raccoons!\n\n-   Relatable (bag under eyes, love naps, out of shape)\n\n-   High volume of data\n\n-   Species of concern for zoonotic diseases\n\n-   Where can we find them in/around Québec?\n\n::: footer\nSee also @higino2021 for more quality 🦝 content\n:::\n\n## Do try this at home!\n\n💻 + 📔 + 🗺️ at `https://github.com/tpoisot/InterpretableSDMWithJulia/`\n\n::: {#include-the-packages-we-need .cell execution_count=1}\n``` {.julia .cell-code}\ninclude(joinpath(\"code\", \"pkg.jl\")); # Dependencies\ninclude(joinpath(\"code\", \"nbc.jl\")); # Naive Bayes Classifier\ninclude(joinpath(\"code\", \"bioclim.jl\")); # BioClim model\ninclude(joinpath(\"code\", \"confusion.jl\")); # Confusion matrix utilities\ninclude(joinpath(\"code\", \"splitters.jl\")); # Cross-validation\ninclude(joinpath(\"code\", \"crossvalidate.jl\")); # Cross-validation\ninclude(joinpath(\"code\", \"variableselection.jl\")); # Variable selection\ninclude(joinpath(\"code\", \"shapley.jl\")); # Shapley values\ninclude(joinpath(\"code\", \"palettes.jl\")); # Color palettes\n```\n:::\n\n\n## To train a model, we need...\n\nA response variable $y$\n\n:   presence or absence of a species at a location identified by its latitude and longitude\n\nA series of predictors $\\mathbf{x}$\n\n:   bioclimatic variables\n\nA series of predictions $\\hat y$\n\n:   which we will compare to the values of $y$\n\n## Species occurrence filtering\n\nWe use the [GBIF] API through the `GBIF` package to get data about *Procyon lotor*\n\n  [GBIF]: http://gbif.org\n\n::: {#get-the-species-from-gbif .cell execution_count=2}\n``` {.julia .cell-code}\nboundingbox = (bottom=54.597528,left=3.515625,top=71.497037,right=42.451172)\ncritter = taxon(\"Rangifer tarandus tarandus\"; strict=false)\nquery = [\n    \"occurrenceStatus\" => \"PRESENT\",\n    \"hasCoordinate\" => true,\n    \"decimalLatitude\" => (boundingbox.bottom, boundingbox.top),\n    \"decimalLongitude\" => (boundingbox.left, boundingbox.right),\n    \"limit\" => 300,\n]\nobservations = occurrences(critter, query...)\n```\n:::\n\n\nWe only consider occurrences within the bounding box!\n\n::: {#get-the-initial-round-of-occurrences .cell execution_count=3}\n``` {.julia .cell-code}\nwhile length(observations) < 5000\n    occurrences!(observations)\nend\n```\n:::\n\n\n::: footer\nSee @dansereau2021 for more about these packages\n:::\n\n\n## Bioclimatic data\n\nWe collect BioClim data from CHELSA v1, using `SpeciesDistributionToolkit`\n\n::: {#download-the-bioclim-data-from-worldclim2 .cell execution_count=4}\n``` {.julia .cell-code}\nprovider = RasterData(WorldClim2, BioClim)\nopts = (; resolution=10.0)\ntemperature = SimpleSDMPredictor(provider, layer=1; opts..., boundingbox...)\n```\n:::\n\n\n::: footer\nBioClim data from @karger2020\n:::\n\n## Where are we so far?\n\n::: {#6edbc1c7 .cell execution_count=5}\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](slides_files/figure-revealjs/cell-6-output-1.png){}\n:::\n:::\n\n\n## WAIT!\n\nIt's not serious ecology unless we use Phylopic:\n\n::: {#phylopic-image .cell execution_count=6}\n``` {.julia .cell-code}\nphylopic_uuid = Phylopic.imagesof(critter; items = 1)\nsilhouette = phylopic_uuid |>\n    Phylopic.thumbnail |>\n    Downloads.download |>\n    Images.load\n```\n:::\n\n\n📢 *Always* use the `Phylopic.attribution` function!\n\n::: footer\nImage of *Rangifer tarandus* provided by [Laura Barbero-Palacios](https://creativecommons.org/publicdomain/zero/1.0/)\n\n:::\n\n## Where are we so far?\n\n::: {#74b99cab .cell execution_count=7}\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](slides_files/figure-revealjs/cell-8-output-1.png){}\n:::\n:::\n\n\n## Spatial thinning\n\nWe limit the occurrences to one per grid cell, assigned to the center of the grid cell\n\n::: {#make-the-layer-for-presences .cell execution_count=8}\n``` {.julia .cell-code}\npresence_layer = mask(temperature, observations, Bool)\n```\n:::\n\n\n## Background points generation\n\nWe generate background points proportionally to the distance away from observations, with a 10km buffer around each point with no background point allowed:\n\n::: {#make-the-pseudo-absence-buffer .cell execution_count=9}\n``` {.julia .cell-code}\npossible_background = pseudoabsencemask(DistanceToEvent, presence_layer)\n```\n:::\n\n\nAnd then we sample one pseudo-absence for each occurrence:\n\n::: {#make-the-absence-layer .cell execution_count=10}\n``` {.julia .cell-code}\nabsence_layer = backgroundpoints(\n    possible_background, \n    3sum(presence_layer);\n    replace=false\n)\n```\n:::\n\n\n::: footer\nSee @barbet-massin2012 for more on background points\n:::\n\n## Background points cleaning\n\nWe can remove all of the information that is neither a presence nor a pseudo-absence\n\n::: {#pseudo-absencepresence-remove .cell execution_count=11}\n``` {.julia .cell-code}\nreplace!(absence_layer, false => nothing)\nreplace!(presence_layer, false => nothing)\n```\n:::\n\n\n## Data overview\n\n::: {#93774b90 .cell execution_count=12}\n\n::: {.cell-output .cell-output-display execution_count=14}\n![](slides_files/figure-revealjs/cell-13-output-1.png){}\n:::\n:::\n\n\n\n\n## Preparing the responses and variables\n\n::: {#assemble-y-and-x .cell execution_count=14}\n``` {.julia .cell-code}\nXpresence = hcat([bioclim_var[keys(presence_layer)] for bioclim_var in predictors]...)\nypresence = fill(true, length(presence_layer))\nXabsence = hcat([bioclim_var[keys(absence_layer)] for bioclim_var in predictors]...)\nyabsence = fill(false, length(absence_layer))\nX = vcat(Xpresence, Xabsence)\ny = vcat(ypresence, yabsence)\n```\n:::\n\n\n\n\n## The model -- Naive Bayes Classifier\n\nPrediction:\n\n$$\nP(+|x) = \\frac{P(+)}{P(x)}P(x|+)\n$$\n\nDecision rule:\n\n$$\n\\hat y = \\text{argmax}_j \\, P(\\mathbf{c}_j)\\prod_i P(\\mathbf{x}_i|\\mathbf{c}_j)\n$$\n\n::: footer\nWith $n$ instances and $f$ features, NBC trains *and* predicts in $\\mathcal{O}(n\\times f)$\n:::\n\n## The model -- Naive Bayes Classifier\n\nAssumption of Gaussian distributions:\n\n$$\nP(x|+) = \\text{pdf}(x, \\mathcal{N}(\\mu_+, \\sigma_+))\n$$\n\n## Cross-validation\n\nWe keep an **unseen** *testing* set -- this will be used at the very end to report expected model performance\n\n::: {#testing-set .cell execution_count=16}\n``` {.julia .cell-code}\nidx, tidx = holdout(y, X; permute=true)\n```\n:::\n\n\nFor *validation*, we will run k-folds\n\n::: {#k-folds .cell execution_count=17}\n``` {.julia .cell-code}\nty, tX = y[idx], X[idx,:]\nfolds = kfold(ty, tX; k=10, permute=true)\nk = length(folds)\n```\n:::\n\n\n::: footer\nSee @valavi2018 for more on cross-validation\n:::\n\n## A note on cross-validation\n\nAll models share the same folds\n\n:   we can compare the validation performance across experiments to select the best model\n\nModel performance can be compared\n\n:   we average the relevant summary statistics over each validation set\n\nTesting set is *only* for future evaluation\n\n:   we can only use it once and report the expected performance *of the best model*\n\n## Baseline performance\n\nWe need to get a sense of how difficult the classification problem is:\n\n::: {#ac47a06a .cell execution_count=18}\n``` {.julia .cell-code}\nN_v0 = crossvalidate(naivebayes, ty, tX, folds)\nB_v0 = crossvalidate(bioclim, ty, tX, folds, eps())\n```\n:::\n\n\nThis uses an un-tuned model with all variables and reports the average over all validation sets. In addition, we will always use the BioClim model as a comparison.\n\n## Measures on the confusion matrix\n\n|     | BioClim | NBC                                   |\n|-----|----|---------------------------------------|\n| FPR | 0\\.289 ± 0\\.039 | 0\\.073 ± 0\\.013 |\n| FNR | 0\\.025 ± 0\\.011 | 0\\.391 ± 0\\.051 |\n| TPR | 0\\.975 ± 0\\.011 | 0\\.609 ± 0\\.051 |\n| TNR | 0\\.711 ± 0\\.039 | 0\\.927 ± 0\\.013 |\n| TSS | 0\\.686 ± 0\\.039 | 0\\.536 ± 0\\.055 |\n| MCC | 0\\.597 ± 0\\.048 | 0\\.571 ± 0\\.051 |\n\n::: footer\nIt's a good idea to check the values for the training sets too...\n:::\n\n## Variable selection\n\nWe add variables one at a time, until the Matthew's Correlation Coefficient stops increasing -- we keep annual temperature, isothermality, mean diurnal range, and annual precipitation\n\n::: {#8c799b19 .cell execution_count=19}\n``` {.julia .cell-code}\navailable_variables = forwardselection(ty, tX, folds, naivebayes, mcc)\n```\n:::\n\n\nThis method identifies 4 variables, some of which are:\n\n1.  Mean Temperature of Warmest Quarter\n\n2.  Mean Temperature of Coldest Quarter\n\n3.  Isothermality \\(BIO2/BIO7\\) \\(×100\\)\n\n## Discuss - can we force variable selection?\n\n-   constrained variable selection\n\n-   VIF + variable selection\n\n-   PCA?\n\n## Model with variable selection\n\n::: {#c05695ff .cell execution_count=20}\n``` {.julia .cell-code}\nN_v1 = crossvalidate(naivebayes, ty, tX[:,available_variables], folds)\nB_v1 = crossvalidate(bioclim, ty, tX[:,available_variables], folds, eps())\n```\n:::\n\n\n## Measures on the confusion matrix\n\n|     | BioClim | NBC  | BioClim (v.s.) | NBC (v.s.)  |\n|-----|----|-----------|----|-----------|\n| FPR | 0\\.289 ± 0\\.039 | 0\\.073 ± 0\\.013 | 0\\.481 ± 0\\.04 | 0\\.088 ± 0\\.01 |\n| FNR | 0\\.025 ± 0\\.011 | 0\\.391 ± 0\\.051 | 0\\.009 ± 0\\.011 | 0\\.153 ± 0\\.051 |\n| TPR | 0\\.975 ± 0\\.011 | 0\\.609 ± 0\\.051 | 0\\.991 ± 0\\.011 | 0\\.847 ± 0\\.051 |\n| TNR | 0\\.711 ± 0\\.039 | 0\\.927 ± 0\\.013 | 0\\.519 ± 0\\.04 | 0\\.912 ± 0\\.01 |\n| TSS | 0\\.686 ± 0\\.039 | 0\\.536 ± 0\\.055 | 0\\.51 ± 0\\.035 | 0\\.759 ± 0\\.044 |\n| MCC | 0\\.597 ± 0\\.048 | 0\\.571 ± 0\\.051 | 0\\.454 ± 0\\.03 | 0\\.733 ± 0\\.036 |\n\n## How do we make the model better?\n\nThe NBC is a *probabilistic classifier* returning $P(+|\\mathbf{x})$\n\nThe *decision rule* is to assign a presence when $P(\\cdot) > 0.5$\n\nBut $P(\\cdot) > \\tau$ is a far more general approach, and we can use learning curves to identify $\\tau$\n\n## Thresholding the model\n\n::: {#43f1261c .cell execution_count=21}\n``` {.julia .cell-code}\nthr = LinRange(0.0, 1.0, 350)\nT = hcat([crossvalidate(naivebayes, ty, tX[:,available_variables], folds, t) for t in thr]...)\n```\n:::\n\n\n## But how do we pick the threshold?\n\n::: {#aff36e5b .cell execution_count=22}\n\n::: {.cell-output .cell-output-display execution_count=27}\n![](slides_files/figure-revealjs/cell-23-output-1.svg){}\n:::\n:::\n\n\n## Tuned model with selected variables\n\n::: {#306c988d .cell execution_count=23}\n``` {.julia .cell-code}\nN_v2 = crossvalidate(naivebayes, ty, tX[:,available_variables], folds, thr[m])\n```\n:::\n\n\n## Measures on the confusion matrix\n\n|     | BioClim | NBC  | BioClim (v.s.) | NBC (v.s.)  | NBC (v.s. + tuning)  |\n|-----|----|-----------|----|-----------|----|\n| FPR | 0\\.289 ± 0\\.039 | 0\\.073 ± 0\\.013 | 0\\.481 ± 0\\.04 | 0\\.088 ± 0\\.01 | 0\\.115 ± 0\\.012 |\n| FNR | 0\\.025 ± 0\\.011 | 0\\.391 ± 0\\.051 | 0\\.009 ± 0\\.011 | 0\\.153 ± 0\\.051 | 0\\.082 ± 0\\.03 |\n| TPR | 0\\.975 ± 0\\.011 | 0\\.609 ± 0\\.051 | 0\\.991 ± 0\\.011 | 0\\.847 ± 0\\.051 | 0\\.918 ± 0\\.03 |\n| TNR | 0\\.711 ± 0\\.039 | 0\\.927 ± 0\\.013 | 0\\.519 ± 0\\.04 | 0\\.912 ± 0\\.01 | 0\\.885 ± 0\\.012 |\n| TSS | 0\\.686 ± 0\\.039 | 0\\.536 ± 0\\.055 | 0\\.51 ± 0\\.035 | 0\\.759 ± 0\\.044 | 0\\.803 ± 0\\.024 |\n| MCC | 0\\.597 ± 0\\.048 | 0\\.571 ± 0\\.051 | 0\\.454 ± 0\\.03 | 0\\.733 ± 0\\.036 | 0\\.748 ± 0\\.026 |\n\n## Tuned model performance\n\nWe can retrain over *all* the training data\n\n::: {#7f812f9f .cell execution_count=24}\n``` {.julia .cell-code}\nfinalmodel = naivebayes(ty, tX[:,available_variables])\nprediction = vec(mapslices(finalmodel, X[tidx,available_variables]; dims=2))\nC = ConfusionMatrix(prediction, y[tidx], thr[m])\n```\n:::\n\n\n## Estimated performance\n\n|     | Final model                        |\n|-----|------------------------------------|\n| FPR | 0\\.118 |\n| FNR | 0\\.114 |\n| TPR | 0\\.886 |\n| TNR | 0\\.882 |\n| MCC | 0\\.768 |\n| MCC | 0\\.711 |\n\n## Acceptable bias\n\n-   false positives: we expect that our knowledge of the distribution is incomplete!\n\n-   false negatives: we used a heuristic for background points!\n\n## Prediction for each pixel\n\n\n\n::: {#3bbcf624 .cell execution_count=26}\n``` {.julia .cell-code}\nprediction = similar(first(predictors), Float64)\nThreads.@threads for k in keys(prediction)\n    prediction[k] = finalmodel([p[k] for p in predictors[available_variables]])\n    if isnan(prediction[k])\n        prediction[k] = 0.0\n    end\nend\n```\n:::\n\n\n## Tuned model - prediction\n\n::: {#6d62e6b9 .cell execution_count=27}\n\n::: {.cell-output .cell-output-display execution_count=34}\n![](slides_files/figure-revealjs/cell-28-output-1.png){}\n:::\n:::\n\n\n## Tuned model - uncertainty\n\n::: {#97b4ca62 .cell execution_count=28}\n\n::: {.cell-output .cell-output-display execution_count=35}\n![](slides_files/figure-revealjs/cell-29-output-1.png){}\n:::\n:::\n\n\n::: footer\nIQR for the models trained on each fold\n:::\n\n## Tuned model - entropy\n\n::: {#e8c7b929 .cell execution_count=29}\n\n::: {.cell-output .cell-output-display execution_count=36}\n![](slides_files/figure-revealjs/cell-30-output-1.png){}\n:::\n:::\n\n\n::: footer\nEntropy (in bits) of the NBC probability\n:::\n\n## Tuned model - range\n\n::: {#b5c4dd03 .cell execution_count=30}\n\n::: {.cell-output .cell-output-display execution_count=37}\n![](slides_files/figure-revealjs/cell-31-output-1.png){}\n:::\n:::\n\n\n::: footer\nProbability \\> 0.367\n:::\n\n## Predicting the predictions?\n\nShapley values (Monte-Carlo approximation): if we mix the variables across two observations, how important is the $i$-th variable?\n\nExpresses \"importance\" as an additive factor on top of the *average* prediction (here: average prob. of occurrence)\n\n::: {#421c0838 .cell execution_count=31}\n``` {.julia .cell-code}\nshapval = [similar(first(predictors), Float64) for i in eachindex(available_variables)]\nThreads.@threads for k in keys(shapval[1])\n    x = [p[k] for p in predictors[available_variables]]\n    for i in axes(shapval, 1)\n        shapval[i][k] = shapleyvalues(finalmodel, tX[:,available_variables], x, i; M=50)\n        if isnan(shapval[i][k])\n            shapval[i][k] = 0.0\n        end\n    end\nend\n```\n:::\n\n\n## Importance of variables\n\n::: {#9544503e .cell execution_count=32}\n``` {.julia .cell-code}\nvarimp = sum.(map(abs, shapval))\nvarimp ./= sum(varimp)\nfor v in sortperm(varimp, rev=true)\n    vname = variables[available_variables[v]][2]\n    vctr = round(Int, varimp[v]*100)\n    println(\"$(vname) - $(vctr)%\")\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMean Temperature of Warmest Quarter - 65%\nMean Temperature of Coldest Quarter - 14%\nIsothermality (BIO2/BIO7) (×100) - 12%\nMin Temperature of Coldest Month - 10%\n```\n:::\n:::\n\n\nThere is a difference between **contributing to model performance** and **contributing to model explainability**\n\n## Top three variables\n\n::: {#1a0a0440 .cell execution_count=33}\n\n::: {.cell-output .cell-output-display execution_count=41}\n![](slides_files/figure-revealjs/cell-34-output-1.png){}\n:::\n:::\n\n\n## Most determinant predictor\n\n::: {#febed0b7 .cell execution_count=34}\n\n::: {.cell-output .cell-output-display execution_count=42}\n![](slides_files/figure-revealjs/cell-35-output-1.png){}\n:::\n:::\n\n\n## Take-home\n\n-   building a model is *incremental*\n\n-   each step adds arbitrary decisions we can control for, justify, or live with\n\n-   we can provide explanations for every single prediction\n\n-   free online textbook (in development) at `https://tpoisot.github.io/DataSciForBiodivSci/`\n\n## References\n\n",
    "supporting": [
      "slides_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}